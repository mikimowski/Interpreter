module AbsPswift where

-- Haskell module generated by the BNF converter

type Position = Maybe (Int, Int)

data Program a = Program a [Stmt a]
  deriving (Eq, Ord, Show, Read)

newtype Ident = Ident String deriving (Eq, Ord, Show, Read)

data Item a = NoInit a Ident | Init a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

data Stmt a
    = DeclVar a (Type a) [Item a]
    | DeclFunc a (Type a) Ident [DeclArg a] (Block a)
    | Empty a
    | BStmt a (Block a)
    | Ass a Ident (Expr a)
    | ListAss a (Expr a) (Expr a) (Expr a)
    | TupleAssUnpack a [TupleIdent a] (Expr a)
    | Ret a (Expr a)
    | Cond a (Expr a) (Block a)
    | CondElse a (Expr a) (Block a) (Block a)
    | While a (Expr a) (Block a)
    | Break a
    | Continue a
    | SExp a (Expr a)
  deriving (Eq, Ord, Show, Read)

data DeclArg a = DeclArg a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

data Block a = Block a [Stmt a]
  deriving (Eq, Ord, Show, Read)

data TupleIdent a
    = TupleAssIdent a Ident
    | TupleAssVarInit a (Type a) Ident
    | TupleAssListEl a Ident (Expr a)
    | TupleAssNested a [TupleIdent a]
  deriving (Eq, Ord, Show, Read)


-- JokerType is used to enable common 'print' function for all the types
data Type a
    = SimpleType a (SimpleType a) | CompositeType a (CompositeType a) | JokerType a
  deriving (Ord, Read)

instance (Eq a) => Eq (Type a) where
  (JokerType _) == (SimpleType _ _) = True
  (SimpleType _ _) == (JokerType _) = True
  (JokerType _) == (CompositeType _ _) = True
  (CompositeType _ _) == (JokerType _) = True
  (SimpleType _ type1) == (SimpleType _ type2) = type1 == type2
  (CompositeType _ type1) == (CompositeType _ type2) = type1 == type2
  _ == _ = False

instance Show (Type a) where
    show (SimpleType _ simpleType) = show simpleType
    show (CompositeType _ compositeType) = show compositeType
    show (JokerType _) = "JokerType"

data SimpleType a = Int a | String a | Bool a
  deriving (Ord, Read)

instance (Eq a) => Eq (SimpleType a) where
    (Int _) == (Int _) = True
    (String _) == (String _) = True
    (Bool _) == (Bool _) = True
    _ == _ = False

instance Show (SimpleType a) where
  show (Int _) = "int"
  show (String _) = "string"
  show (Bool _) = "bool"

data CompositeType a = List a (SimpleType a) | Tuple a [Type a] | ListUntyped a | TupleGeneric a
  deriving (Ord, Read)

instance (Eq a) => Eq (CompositeType a) where
  (List _ type1) == (List _ type2) = type1 == type2
  (Tuple _ types1) == (Tuple _ types2) = types1 == types2
  (TupleGeneric _) == (Tuple _ _) = True
  (Tuple _ _) == (TupleGeneric _) = True
  (TupleGeneric _) == (TupleGeneric _) = True
  (ListUntyped _) == (List _ _) = True
  (List _ _) == (ListUntyped _) = True
  (ListUntyped _) == (ListUntyped _) = True
  _ == _ = False

concatenateTypes :: String -> [Type a] -> String
concatenateTypes _ [] = ""
concatenateTypes sep (type1:[]) = show type1
concatenateTypes sep (type1:types) = show type1 ++ sep ++ (concatenateTypes sep types)

instance Show (CompositeType a) where
    show (Tuple _ types) = "<" ++ (concatenateTypes ", " types) ++ ">"
    show (TupleGeneric _) = "TupleType"
    show (List _ simpleType) = "[" ++ (show simpleType) ++ "]"
    show (ListUntyped _) = "ListUntyped []"

data FuncArg a = FuncArgVal a (Expr a) | FuncArgRef a Ident
  deriving (Eq, Ord, Show, Read)

data Expr a
    = EVar a Ident
    | ELitInt a Integer
    | ELitTrue a
    | ELitFalse a
    | EApp a Ident [FuncArg a]
    | EString a String
    | EList a [Expr a]
    | EGetEl a (Expr a) (Expr a)
    | ETuple a (Expr a) [Expr a]
    | Neg a (Expr a)
    | Not a (Expr a)
    | EMul a (Expr a) (MulOp a) (Expr a)
    | EAdd a (Expr a) (AddOp a) (Expr a)
    | ERel a (Expr a) (RelOp a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

data AddOp a = Plus a | Minus a
  deriving (Eq, Ord, Show, Read)

data MulOp a = Times a | Div a | Mod a
  deriving (Eq, Ord, Show, Read)

data RelOp a = LTH a | LE a | GTH a | GE a | EQU a | NE a
  deriving (Eq, Ord, Show, Read)





instance Functor Program where
    fmap f x = case x of
        Program a stmts -> Program (f a) (map (fmap f) stmts)

instance Functor Stmt where
    fmap f x = case x of
        DeclVar a type_ items -> DeclVar (f a) (fmap f type_) (map (fmap f) items)
        DeclFunc a type_ ident declargs block -> DeclFunc (f a) (fmap f type_) ident (map (fmap f) declargs) (fmap f block)
        Empty a -> Empty (f a)
        BStmt a block -> BStmt (f a) (fmap f block)
        Ass a ident expr -> Ass (f a) ident (fmap f expr)
        ListAss a expr1 expr2 expr3 -> ListAss (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3)
        TupleAssUnpack a tupleidents expr -> TupleAssUnpack (f a) (map (fmap f) tupleidents) (fmap f expr)
        Ret a expr -> Ret (f a) (fmap f expr)
        Cond a expr block -> Cond (f a) (fmap f expr) (fmap f block)
        CondElse a expr block1 block2 -> CondElse (f a) (fmap f expr) (fmap f block1) (fmap f block2)
        While a expr block -> While (f a) (fmap f expr) (fmap f block)
        Break a -> Break (f a)
        Continue a -> Continue (f a)
        SExp a expr -> SExp (f a) (fmap f expr)

instance Functor Item where
    fmap f x = case x of
        NoInit a ident -> NoInit (f a) ident
        Init a ident expr -> Init (f a) ident (fmap f expr)

instance Functor DeclArg where
    fmap f x = case x of
        DeclArg a type_ ident -> DeclArg (f a) (fmap f type_) ident

instance Functor Block where
    fmap f x = case x of
        Block a stmts -> Block (f a) (map (fmap f) stmts)

instance Functor TupleIdent where
    fmap f x = case x of
        TupleAssIdent a ident -> TupleAssIdent (f a) ident
        TupleAssVarInit a type_ ident -> TupleAssVarInit (f a) (fmap f type_) ident
        TupleAssListEl a ident expr -> TupleAssListEl (f a) ident (fmap f expr)
        TupleAssNested a tupleidents -> TupleAssNested (f a) (map (fmap f) tupleidents)

instance Functor Type where
    fmap f x = case x of
        SimpleType a simpletype -> SimpleType (f a) (fmap f simpletype)
        CompositeType a compositetype -> CompositeType (f a) (fmap f compositetype)


instance Functor SimpleType where
    fmap f x = case x of
        Int a -> Int (f a)
        String a -> String (f a)
        Bool a -> Bool (f a)

instance Functor CompositeType where
    fmap f x = case x of
        List a simpletype -> List (f a) (fmap f simpletype)
        Tuple a types -> Tuple (f a) (map (fmap f) types)

instance Functor FuncArg where
    fmap f x = case x of
        FuncArgVal a expr -> FuncArgVal (f a) (fmap f expr)
        FuncArgRef a ident -> FuncArgRef (f a) ident

instance Functor Expr where
    fmap f x = case x of
        EVar a ident -> EVar (f a) ident
        ELitInt a integer -> ELitInt (f a) integer
        ELitTrue a -> ELitTrue (f a)
        ELitFalse a -> ELitFalse (f a)
        EApp a ident funargs -> EApp (f a) ident (map (fmap f) funargs)
        EString a string -> EString (f a) string
        EList a exprs -> EList (f a) (map (fmap f) exprs)
        EGetEl a expr1 expr2 -> EGetEl (f a) (fmap f expr1) (fmap f expr2)
        ETuple a expr exprs -> ETuple (f a) (fmap f expr) (map (fmap f) exprs)
        Neg a expr -> Neg (f a) (fmap f expr)
        Not a expr -> Not (f a) (fmap f expr)
        EMul a expr1 mulop expr2 -> EMul (f a) (fmap f expr1) (fmap f mulop) (fmap f expr2)
        EAdd a expr1 addop expr2 -> EAdd (f a) (fmap f expr1) (fmap f addop) (fmap f expr2)
        ERel a expr1 relop expr2 -> ERel (f a) (fmap f expr1) (fmap f relop) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)

instance Functor AddOp where
    fmap f x = case x of
        Plus a -> Plus (f a)
        Minus a -> Minus (f a)

instance Functor MulOp where
    fmap f x = case x of
        Times a -> Times (f a)
        Div a -> Div (f a)
        Mod a -> Mod (f a)

instance Functor RelOp where
    fmap f x = case x of
        LTH a -> LTH (f a)
        LE a -> LE (f a)
        GTH a -> GTH (f a)
        GE a -> GE (f a)
        EQU a -> EQU (f a)
        NE a -> NE (f a)